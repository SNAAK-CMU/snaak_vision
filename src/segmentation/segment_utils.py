"""
Script with helper functions for segmentation related tasks
"""

import numpy as np
import matplotlib.pyplot as plt
import cv2


def convert_mask_to_orig_dims(
    cropped_mask, orig_img, crop_xmin, crop_ymin, crop_xmax, crop_ymax
):
    """
    Extend mask to match the original image dimensions by padding with zeros
    """
    orig_mask = np.zeros_like(orig_img[:, :, 0], dtype=np.uint8)
    orig_mask[crop_ymin:crop_ymax, crop_xmin:crop_xmax] = cropped_mask
    return orig_mask


def show_mask(mask, ax, random_color=False, borders=True):
    """
    Show mask with matplotlib
    """
    if random_color:
        color = np.concatenate([np.random.random(3), np.array([0.6])], axis=0)
    else:
        color = np.array([30 / 255, 144 / 255, 255 / 255, 0.6])
    h, w = mask.shape[-2:]
    mask = mask.astype(np.uint8)
    mask_image = mask.reshape(h, w, 1) * color.reshape(1, 1, -1)
    if borders:
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
        # Try to smooth contours
        contours = [
            cv2.approxPolyDP(contour, epsilon=0.01, closed=True) for contour in contours
        ]
        mask_image = cv2.drawContours(
            mask_image, contours, -1, (1, 1, 1, 0.5), thickness=2
        )
    ax.imshow(mask_image)


def show_points(coords, labels, ax, marker_size=150):
    """
    Plot points on an image using matplotlib
    """
    pos_points = coords[labels == 1]
    neg_points = coords[labels == 0]
    ax.scatter(
        pos_points[:, 0],
        pos_points[:, 1],
        color="green",
        marker="o",
        s=marker_size,
        edgecolor="white",
        linewidth=1.25,
    )
    ax.scatter(
        neg_points[:, 0],
        neg_points[:, 1],
        color="red",
        marker="o",
        s=marker_size,
        edgecolor="white",
        linewidth=1.25,
    )


def show_box(box, ax):
    """
    Plot box on an image using matplotlib
    """
    x0, y0 = box[0], box[1]
    w, h = box[2] - box[0], box[3] - box[1]
    ax.add_patch(
        plt.Rectangle((x0, y0), w, h, edgecolor="green", facecolor=(0, 0, 0, 0), lw=2)
    )


def show_masks(
    image,
    masks,
    scores,
    point_coords=None,
    box_coords=None,
    input_labels=None,
    borders=True,
):
    """
    Displays all masks generated by SAM using matplotlib
    """
    for i, (mask, score) in enumerate(zip(masks, scores)):
        plt.figure(figsize=(10, 10))
        plt.imshow(image)
        show_mask(mask, plt.gca(), borders=borders)
        if point_coords is not None:
            assert input_labels is not None
            show_points(point_coords, input_labels, plt.gca())
        if box_coords is not None:
            # boxes
            show_box(box_coords, plt.gca())
        if len(scores) > 1:
            plt.title(f"Mask {i+1}, Score: {score:.3f}", fontsize=18)
        plt.axis("off")
        plt.show()


def get_hsv_range(roi):
    """
    Get lower and upper hsv range for all pixels in the region of interest (roi)
    """
    roi_hsv = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)
    h_min = np.min(roi_hsv[:, :, 0])
    h_max = np.max(roi_hsv[:, :, 0])
    s_min = np.min(roi_hsv[:, :, 1])
    s_max = np.max(roi_hsv[:, :, 1])
    v_min = np.min(roi_hsv[:, :, 2])
    v_max = np.max(roi_hsv[:, :, 2])

    # Define HSV lower and upper bounds
    lower_hsv = np.array([h_min, s_min, v_min])
    upper_hsv = np.array([h_max, s_max, v_max])

    return lower_hsv, upper_hsv


def segment_from_hsv(image, lower_hsv, upper_hsv):
    """
    Segment given image using HSV segmentation
    """
    hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    mask = cv2.inRange(hsv_image, lower_hsv, upper_hsv)
    return mask


def calc_bbox_from_mask(mask):
    """
    Calculate a single box to bound all the white regions int he mask
    """
    bbox = None
    y_indices, x_indices = np.where(mask == 255)  # Get row (y) and column (x) indices

    # Compute bounding box coordinates
    if y_indices.size > 0 and x_indices.size > 0:  # Ensure there are white pixels
        xmin, xmax = np.min(x_indices), np.max(x_indices)
        ymin, ymax = np.min(y_indices), np.max(y_indices)
        bbox = np.array([xmin, ymin, xmax, ymax])

    return bbox


def keep_largest_blob(binary_image):
    """
    Remove all white blobs from the mask except the largest blob
    """
    contours, _ = cv2.findContours(
        binary_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
    )

    if not contours:
        return binary_image

    largest_contour = max(contours, key=cv2.contourArea)
    largest_blob_image = np.zeros_like(binary_image)
    cv2.drawContours(
        largest_blob_image, [largest_contour], -1, 255, thickness=cv2.FILLED
    )
    return largest_blob_image

def contour_segmentation(image, binary_threshold=150, show_image=True, show_separate_contours=False, show_steps=False):
     # can adjust the threshold value (150) based on the image characteristics

    original_image = image.copy()

    # Step 1: Preprocessing (convert to grayscale and apply Gaussian blur)
    gray = cv2.cvtColor(original_image, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    

    # Step 2.1: Binary Thresholding
    _, binary = cv2.threshold(blurred, binary_threshold, 255, cv2.THRESH_BINARY_INV)
    
    # Step 2.2: HSV Thresholding
    # TODO
    

    # Step 3: Morphological Operations
    kernel = np.ones((5, 5), np.uint8)
    binary_closed = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)  # Close gaps
    binary_opened = cv2.morphologyEx(binary_closed, cv2.MORPH_OPEN, kernel)   # Remove noise
    
    if show_steps:
        plt.figure(figsize=(12, 8))
        plt.subplot(1, 4, 1)
        plt.title("Original Image")
        plt.imshow(cv2.cvtColor(original_image, cv2.COLOR_BGR2RGB))
        plt.subplot(1, 4, 2)
        plt.title("Grayscale Image")
        plt.imshow(gray, cmap="gray")
        plt.subplot(1, 4, 3)
        plt.title("Blurred Image")
        plt.imshow(blurred, cmap="gray")
        plt.subplot(1, 4, 4)
        plt.title("Binary Image")
        plt.imshow(binary_opened, cmap="gray")
        plt.show()
    

    # Step 4: Contour Detection
    contours, heirarchy = cv2.findContours(binary_opened, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    print(f"Number of contours detected: {len(contours)}")
    
    # Visualize All Detected Contours
    if show_image:
        contour_image_all = original_image.copy()
        cv2.drawContours(contour_image_all, contours, -1, (0, 255, 0), thickness=2)
        plt.figure(figsize=(6, 6))
        plt.title("All Detected Contours")
        plt.imshow(cv2.cvtColor(contour_image_all, cv2.COLOR_BGR2RGB))
   
     # Visualize each separate contour and its area
    if show_separate_contours:
        for i, contour in enumerate(contours):
            area = cv2.contourArea(contour)
            print(f"Contour {i}: Area = {area}")

            # Create a mask for the current contour
            mask = np.zeros_like(gray)
            cv2.drawContours(mask, [contour], -1, (255), thickness=cv2.FILLED)

            # Apply mask to the original image to segment the contour
            segmented_contour = cv2.bitwise_and(original_image, original_image, mask=mask)

            # Visualize the segmented contour
            plt.figure(figsize=(6, 6))
            plt.title(f"Segmented Contour {i} (Area = {area})")
            plt.imshow(cv2.cvtColor(segmented_contour, cv2.COLOR_BGR2RGB))
            plt.axis('off')
            plt.show()

    return contours

def difference_mask(image1, image2, thresh):
    """
    Segment out those pixels that changed from the previous image
    """
    # convert images to grayscale for comparison
    gray1 = cv2.cvtColor(image1, cv2.COLOR_BGR2GRAY)
    gray2 = cv2.cvtColor(image2, cv2.COLOR_BGR2GRAY)

    #compute Absolute Difference
    difference = cv2.absdiff(gray1, gray2)

    #threshold the Difference to Isolate Changed Pixels
    _, thresholded_diff = cv2.threshold(difference, thresh, 255, cv2.THRESH_BINARY) # 10 is the pixel difference threshold value - adjust according to your needs

    #morphological Operations
    kernel = np.ones((5, 5), np.uint8)
    thresholded_diff = cv2.morphologyEx(thresholded_diff, cv2.MORPH_CLOSE, kernel)  # Fill gaps
    
    # apply Mask to Original Image (Highlight Changes)
    # changed_pixels_image = cv2.bitwise_and(image2, image2, mask=mask)

    # # Visualization of Results
    # plt.figure(figsize=(12, 8))

    # plt.subplot(1, 3, 1)
    # plt.title("Image 1")
    # plt.imshow(cv2.cvtColor(image1, cv2.COLOR_BGR2RGB))

    # plt.subplot(1, 3, 2)
    # plt.title("Image 2")
    # plt.imshow(cv2.cvtColor(image2, cv2.COLOR_BGR2RGB))

    # plt.subplot(1, 3, 3)
    # plt.title("Changed Pixels Highlighted")
    # plt.imshow(cv2.cvtColor(changed_pixels_image, cv2.COLOR_BGR2RGB))

    # plt.tight_layout()
    # plt.show()


    return thresholded_diff
